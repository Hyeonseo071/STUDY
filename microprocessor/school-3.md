### 수업내용 정리(3차시)

저번 시간에는 포인터의 개념과 각 포인터와 주소가 데이터를 담을 수 있는 크기 및 포인터를 배열처럼 사용할 수 있는 포인터 배열 등에 대해서 배우고 직접 실습해보는 위주로 수업이 진행되었다.
이번 시간에는 지난 시간에 이어 다차원 배열과 포인터의 상관관계에 대해서 배우는 시간을 가져보았다.(+ 구조체 약간)
평소대로 ... 수업이 진행되려던 찰나. 우리 반에서 코로나에 걸려버린 친구들이 격리되는 와중에도 마프 수업을 듣고 싶다는 문의가 들어왔다. 선생님께서는 아프더라도 수업을 들으려는 열정어린 학생들을 말리지 않으시고 흔쾌히 줌으로 듣는 것을 허락해주셔서 모두가 나란히 수업을 경청할 수 있었다~
우선, 우린 컴퓨터 프로그래밍에서 데이터 처리의 단위를 한 단어로 word라고 부른다.
더 자세히 풀어 말하자면, 한번에 처리하는 데이터가 64bit인 것을 word라고 정의하는 것이다. 이때, 전 시간에 배웠던 int형과 포인터의 크기는 각 4byte(32bit)라고 배웠지만, 그건 32bit 체계의 컴퓨터에 해당하는 것이고, 더 뛰어난 데이터 처리를 담당하는 64bit 컴퓨터 체계에서는 int와 포인터의 크기가 각각 4byte(or 8byte), 8byte(64bit) 인 것이다.

- 따라서 정리를 해보자면, 64비트 시스템 컴퓨터에서는 word = 64bit, int = 4byte, point = 8byte

그 다음, 1차원 배열과 포인터를 활용한 예제에 대해서 배운 점이 있는데, (3-8을 예시로 들면)
(include ~ 생략, 이때, a[3] = {10, 20, 30};)
printf("%p %p %p\n", a, a + 0, &a[0]); //배열의 0번째 주소 출력
printf("%p %p\n", a + 1, &a[1]);     //배열의 1번째 주소 출력
printf("%d %d %d\n", sizeof(a), sizeof(a + 0), sizeof(&a[0])); //배열의 “크기”출력

위 세 번째 줄에서 sizeof는 배열 a의 “크기”를 출력하게 된다(주소 값 X). 즉, 
- sizeof(a) = (전체 배열의 크기이고, int(4byte)으로 정의된 전체 배열의 크기는) 4 x 3 = 12바이트 인 것이며,
- sizeof(a + 1) = 이것은 배열의 첫 번째 주소를 가리키는 포인터를 의미하므로 따라서 8byte를 의미하는 것이다. (나머지 &a[0]도 마찬가지) 
사실 이때부터 머릿속이 어지러웠지만, 새롭게 배운 내용을 토대로 배열과 포인터가 상호 호완할 수 있음을 알게 되었다.
그리고 또 인상 깊게 배운 내용 중 하나로는 ‘2차원 배열과 포인터’인 것 같다.
2차원 배열에 대한 포인터 선언은 ‘자료형과 열의 수가 같으면 행에 상관없이 포인터의 선언이 일치 한다’ 고 한다.
따라서 - char a[4][3]; -> char (*p)[3];
       - int b[3][5]; -> int (*p)[5];
처럼 선언해줄 수 있다.
또한 형변환을 이용하여 특정 배열의 n번째 요소를 참조하는 법에 대해서도 배우게 되었다.
-> a[0][0] == (*(a+0))[0] == *(a[0]+0) == a[0][0] 

이날 한번에 많은 정보들을 머릿속에 집어넣어서 어렵기도 하고 힘들기도 했지만 전보다 포인터와 배열에 대해서 자세히 짚고 넘어간 것 같아서 좋은 것 같다.